"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/peberminta";
exports.ids = ["vendor-chunks/peberminta"];
exports.modules = {

/***/ "(action-browser)/./node_modules/peberminta/lib/core.mjs":
/*!**********************************************!*\
  !*** ./node_modules/peberminta/lib/core.mjs ***!
  \**********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ab: () => (/* binding */ ab),\n/* harmony export */   abc: () => (/* binding */ abc),\n/* harmony export */   action: () => (/* binding */ action),\n/* harmony export */   ahead: () => (/* binding */ ahead),\n/* harmony export */   all: () => (/* binding */ all),\n/* harmony export */   and: () => (/* binding */ all),\n/* harmony export */   any: () => (/* binding */ any),\n/* harmony export */   chain: () => (/* binding */ chain),\n/* harmony export */   chainReduce: () => (/* binding */ chainReduce),\n/* harmony export */   choice: () => (/* binding */ choice),\n/* harmony export */   condition: () => (/* binding */ condition),\n/* harmony export */   decide: () => (/* binding */ decide),\n/* harmony export */   discard: () => (/* binding */ skip),\n/* harmony export */   eitherOr: () => (/* binding */ otherwise),\n/* harmony export */   emit: () => (/* binding */ emit),\n/* harmony export */   end: () => (/* binding */ end),\n/* harmony export */   eof: () => (/* binding */ end),\n/* harmony export */   error: () => (/* binding */ error),\n/* harmony export */   fail: () => (/* binding */ fail),\n/* harmony export */   flatten: () => (/* binding */ flatten),\n/* harmony export */   flatten1: () => (/* binding */ flatten1),\n/* harmony export */   left: () => (/* binding */ left),\n/* harmony export */   leftAssoc1: () => (/* binding */ leftAssoc1),\n/* harmony export */   leftAssoc2: () => (/* binding */ leftAssoc2),\n/* harmony export */   longest: () => (/* binding */ longest),\n/* harmony export */   lookAhead: () => (/* binding */ ahead),\n/* harmony export */   make: () => (/* binding */ make),\n/* harmony export */   many: () => (/* binding */ many),\n/* harmony export */   many1: () => (/* binding */ many1),\n/* harmony export */   map: () => (/* binding */ map),\n/* harmony export */   map1: () => (/* binding */ map1),\n/* harmony export */   match: () => (/* binding */ match),\n/* harmony export */   middle: () => (/* binding */ middle),\n/* harmony export */   not: () => (/* binding */ not),\n/* harmony export */   of: () => (/* binding */ emit),\n/* harmony export */   option: () => (/* binding */ option),\n/* harmony export */   or: () => (/* binding */ choice),\n/* harmony export */   otherwise: () => (/* binding */ otherwise),\n/* harmony export */   parse: () => (/* binding */ parse),\n/* harmony export */   parserPosition: () => (/* binding */ parserPosition),\n/* harmony export */   peek: () => (/* binding */ peek),\n/* harmony export */   recursive: () => (/* binding */ recursive),\n/* harmony export */   reduceLeft: () => (/* binding */ reduceLeft),\n/* harmony export */   reduceRight: () => (/* binding */ reduceRight),\n/* harmony export */   remainingTokensNumber: () => (/* binding */ remainingTokensNumber),\n/* harmony export */   right: () => (/* binding */ right),\n/* harmony export */   rightAssoc1: () => (/* binding */ rightAssoc1),\n/* harmony export */   rightAssoc2: () => (/* binding */ rightAssoc2),\n/* harmony export */   satisfy: () => (/* binding */ satisfy),\n/* harmony export */   sepBy: () => (/* binding */ sepBy),\n/* harmony export */   sepBy1: () => (/* binding */ sepBy1),\n/* harmony export */   skip: () => (/* binding */ skip),\n/* harmony export */   some: () => (/* binding */ many1),\n/* harmony export */   start: () => (/* binding */ start),\n/* harmony export */   takeUntil: () => (/* binding */ takeUntil),\n/* harmony export */   takeUntilP: () => (/* binding */ takeUntilP),\n/* harmony export */   takeWhile: () => (/* binding */ takeWhile),\n/* harmony export */   takeWhileP: () => (/* binding */ takeWhileP),\n/* harmony export */   token: () => (/* binding */ token),\n/* harmony export */   tryParse: () => (/* binding */ tryParse)\n/* harmony export */ });\n/* harmony import */ var _util_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./util.mjs */ \"(action-browser)/./node_modules/peberminta/lib/util.mjs\");\n\n\nfunction emit(value) {\n    return (data, i) => ({\n        matched: true,\n        position: i,\n        value: value\n    });\n}\nfunction make(\nf) {\n    return (data, i) => ({\n        matched: true,\n        position: i,\n        value: f(data, i)\n    });\n}\nfunction action(\nf) {\n    return (data, i) => {\n        f(data, i);\n        return {\n            matched: true,\n            position: i,\n            value: null\n        };\n    };\n}\nfunction fail(\ndata, i) {\n    return { matched: false };\n}\nfunction error(message) {\n    return (data, i) => {\n        throw new Error((message instanceof Function) ? message(data, i) : message);\n    };\n}\nfunction token(\nonToken,\nonEnd) {\n    return (data, i) => {\n        let position = i;\n        let value = undefined;\n        if (i < data.tokens.length) {\n            value = onToken(data.tokens[i], data, i);\n            if (value !== undefined) {\n                position++;\n            }\n        }\n        else {\n            onEnd?.(data, i);\n        }\n        return (value === undefined)\n            ? { matched: false }\n            : {\n                matched: true,\n                position: position,\n                value: value\n            };\n    };\n}\nfunction any(data, i) {\n    return (i < data.tokens.length)\n        ? {\n            matched: true,\n            position: i + 1,\n            value: data.tokens[i]\n        }\n        : { matched: false };\n}\nfunction satisfy(\ntest) {\n    return (data, i) => (i < data.tokens.length && test(data.tokens[i], data, i))\n        ? {\n            matched: true,\n            position: i + 1,\n            value: data.tokens[i]\n        }\n        : { matched: false };\n}\nfunction mapInner(r, f) {\n    return (r.matched) ? ({\n        matched: true,\n        position: r.position,\n        value: f(r.value, r.position)\n    }) : r;\n}\nfunction mapOuter(r, f) {\n    return (r.matched) ? f(r) : r;\n}\nfunction map(p, mapper) {\n    return (data, i) => mapInner(p(data, i), (v, j) => mapper(v, data, i, j));\n}\nfunction map1(p,\nmapper) {\n    return (data, i) => mapOuter(p(data, i), (m) => mapper(m, data, i));\n}\nfunction peek(p, f) {\n    return (data, i) => {\n        const r = p(data, i);\n        f(r, data, i);\n        return r;\n    };\n}\nfunction option(p, def) {\n    return (data, i) => {\n        const r = p(data, i);\n        return (r.matched)\n            ? r\n            : {\n                matched: true,\n                position: i,\n                value: def\n            };\n    };\n}\nfunction not(p) {\n    return (data, i) => {\n        const r = p(data, i);\n        return (r.matched)\n            ? { matched: false }\n            : {\n                matched: true,\n                position: i,\n                value: true\n            };\n    };\n}\nfunction choice(...ps) {\n    return (data, i) => {\n        for (const p of ps) {\n            const result = p(data, i);\n            if (result.matched) {\n                return result;\n            }\n        }\n        return { matched: false };\n    };\n}\nfunction otherwise(pa, pb) {\n    return (data, i) => {\n        const r1 = pa(data, i);\n        return (r1.matched)\n            ? r1\n            : pb(data, i);\n    };\n}\nfunction longest(...ps) {\n    return (data, i) => {\n        let match = undefined;\n        for (const p of ps) {\n            const result = p(data, i);\n            if (result.matched && (!match || match.position < result.position)) {\n                match = result;\n            }\n        }\n        return match || { matched: false };\n    };\n}\nfunction takeWhile(p,\ntest) {\n    return (data, i) => {\n        const values = [];\n        let success = true;\n        do {\n            const r = p(data, i);\n            if (r.matched && test(r.value, values.length + 1, data, i, r.position)) {\n                values.push(r.value);\n                i = r.position;\n            }\n            else {\n                success = false;\n            }\n        } while (success);\n        return {\n            matched: true,\n            position: i,\n            value: values\n        };\n    };\n}\nfunction takeUntil(p,\ntest) {\n    return takeWhile(p, (value, n, data, i, j) => !test(value, n, data, i, j));\n}\nfunction takeWhileP(pValue, pTest) {\n    return takeWhile(pValue, (value, n, data, i) => pTest(data, i).matched);\n}\nfunction takeUntilP(pValue, pTest) {\n    return takeWhile(pValue, (value, n, data, i) => !pTest(data, i).matched);\n}\nfunction many(p) {\n    return takeWhile(p, () => true);\n}\nfunction many1(p) {\n    return ab(p, many(p), (head, tail) => [head, ...tail]);\n}\nfunction ab(pa, pb,\njoin) {\n    return (data, i) => mapOuter(pa(data, i), (ma) => mapInner(pb(data, ma.position), (vb, j) => join(ma.value, vb, data, i, j)));\n}\nfunction left(pa, pb) {\n    return ab(pa, pb, (va) => va);\n}\nfunction right(pa, pb) {\n    return ab(pa, pb, (va, vb) => vb);\n}\nfunction abc(pa, pb, pc,\njoin) {\n    return (data, i) => mapOuter(pa(data, i), (ma) => mapOuter(pb(data, ma.position), (mb) => mapInner(pc(data, mb.position), (vc, j) => join(ma.value, mb.value, vc, data, i, j))));\n}\nfunction middle(pa, pb, pc) {\n    return abc(pa, pb, pc, (ra, rb) => rb);\n}\nfunction all(...ps) {\n    return (data, i) => {\n        const result = [];\n        let position = i;\n        for (const p of ps) {\n            const r1 = p(data, position);\n            if (r1.matched) {\n                result.push(r1.value);\n                position = r1.position;\n            }\n            else {\n                return { matched: false };\n            }\n        }\n        return {\n            matched: true,\n            position: position,\n            value: result\n        };\n    };\n}\nfunction skip(...ps) {\n    return map(all(...ps), () => null);\n}\nfunction flatten(...ps) {\n    return flatten1(all(...ps));\n}\nfunction flatten1(p) {\n    return map(p, (vs) => vs.flatMap((v) => v));\n}\nfunction sepBy1(pValue, pSep) {\n    return ab(pValue, many(right(pSep, pValue)), (head, tail) => [head, ...tail]);\n}\nfunction sepBy(pValue, pSep) {\n    return otherwise(sepBy1(pValue, pSep), emit([]));\n}\nfunction chainReduce(acc,\nf) {\n    return (data, i) => {\n        let loop = true;\n        let acc1 = acc;\n        let pos = i;\n        do {\n            const r = f(acc1, data, pos)(data, pos);\n            if (r.matched) {\n                acc1 = r.value;\n                pos = r.position;\n            }\n            else {\n                loop = false;\n            }\n        } while (loop);\n        return {\n            matched: true,\n            position: pos,\n            value: acc1\n        };\n    };\n}\nfunction reduceLeft(acc, p,\nreducer) {\n    return chainReduce(acc, (acc) => map(p, (v, data, i, j) => reducer(acc, v, data, i, j)));\n}\nfunction reduceRight(p, acc,\nreducer) {\n    return map(many(p), (vs, data, i, j) => vs.reduceRight((acc, v) => reducer(v, acc, data, i, j), acc));\n}\nfunction leftAssoc1(pLeft, pOper) {\n    return chain(pLeft, (v0) => reduceLeft(v0, pOper, (acc, f) => f(acc)));\n}\nfunction rightAssoc1(pOper, pRight) {\n    return ab(reduceRight(pOper, (y) => y, (f, acc) => (y) => f(acc(y))), pRight, (f, v) => f(v));\n}\nfunction leftAssoc2(pLeft, pOper, pRight) {\n    return chain(pLeft, (v0) => reduceLeft(v0, ab(pOper, pRight, (f, y) => [f, y]), (acc, [f, y]) => f(acc, y)));\n}\nfunction rightAssoc2(pLeft, pOper, pRight) {\n    return ab(reduceRight(ab(pLeft, pOper, (x, f) => [x, f]), (y) => y, ([x, f], acc) => (y) => f(x, acc(y))), pRight, (f, v) => f(v));\n}\nfunction condition(\ncond, pTrue, pFalse) {\n    return (data, i) => (cond(data, i))\n        ? pTrue(data, i)\n        : pFalse(data, i);\n}\nfunction decide(p) {\n    return (data, i) => mapOuter(p(data, i), (m1) => m1.value(data, m1.position));\n}\nfunction chain(p,\nf) {\n    return (data, i) => mapOuter(p(data, i), (m1) => f(m1.value, data, i, m1.position)(data, m1.position));\n}\nfunction ahead(p) {\n    return (data, i) => mapOuter(p(data, i), (m1) => ({\n        matched: true,\n        position: i,\n        value: m1.value\n    }));\n}\nfunction recursive(f) {\n    return function (data, i) {\n        return f()(data, i);\n    };\n}\nfunction start(data, i) {\n    return (i !== 0)\n        ? { matched: false }\n        : {\n            matched: true,\n            position: i,\n            value: true\n        };\n}\nfunction end(data, i) {\n    return (i < data.tokens.length)\n        ? { matched: false }\n        : {\n            matched: true,\n            position: i,\n            value: true\n        };\n}\nfunction remainingTokensNumber(data, i) {\n    return data.tokens.length - i;\n}\nfunction parserPosition(data, i, formatToken, contextTokens = 3) {\n    const len = data.tokens.length;\n    const lowIndex = (0,_util_mjs__WEBPACK_IMPORTED_MODULE_0__.clamp)(0, i - contextTokens, len - contextTokens);\n    const highIndex = (0,_util_mjs__WEBPACK_IMPORTED_MODULE_0__.clamp)(contextTokens, i + 1 + contextTokens, len);\n    const tokensSlice = data.tokens.slice(lowIndex, highIndex);\n    const lines = [];\n    const indexWidth = String(highIndex - 1).length + 1;\n    if (i < 0) {\n        lines.push(`${String(i).padStart(indexWidth)} >>`);\n    }\n    if (0 < lowIndex) {\n        lines.push('...'.padStart(indexWidth + 6));\n    }\n    for (let j = 0; j < tokensSlice.length; j++) {\n        const index = lowIndex + j;\n        lines.push(`${String(index).padStart(indexWidth)} ${(index === i ? '>' : ' ')} ${(0,_util_mjs__WEBPACK_IMPORTED_MODULE_0__.escapeWhitespace)(formatToken(tokensSlice[j]))}`);\n    }\n    if (highIndex < len) {\n        lines.push('...'.padStart(indexWidth + 6));\n    }\n    if (len <= i) {\n        lines.push(`${String(i).padStart(indexWidth)} >>`);\n    }\n    return lines.join('\\n');\n}\nfunction parse(parser, tokens, options, formatToken = JSON.stringify) {\n    const data = { tokens: tokens, options: options };\n    const result = parser(data, 0);\n    if (!result.matched) {\n        throw new Error('No match');\n    }\n    if (result.position < data.tokens.length) {\n        throw new Error(`Partial match. Parsing stopped at:\\n${parserPosition(data, result.position, formatToken)}`);\n    }\n    return result.value;\n}\nfunction tryParse(parser, tokens, options) {\n    const result = parser({ tokens: tokens, options: options }, 0);\n    return (result.matched)\n        ? result.value\n        : undefined;\n}\nfunction match(matcher, tokens, options) {\n    const result = matcher({ tokens: tokens, options: options }, 0);\n    return result.value;\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9wZWJlcm1pbnRhL2xpYi9jb3JlLm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQXFEOztBQUVyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixnREFBSztBQUMxQixzQkFBc0IsZ0RBQUs7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsZ0NBQWdDO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHdCQUF3QjtBQUM1QztBQUNBLHNCQUFzQixvQ0FBb0MsRUFBRSwyQkFBMkIsRUFBRSwyREFBZ0IsOEJBQThCO0FBQ3ZJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsZ0NBQWdDO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrREFBK0QsbURBQW1EO0FBQ2xIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLGtDQUFrQztBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLGtDQUFrQztBQUMvRDtBQUNBOztBQUU0a0IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9teS1wcm9qZWN0Ly4vbm9kZV9tb2R1bGVzL3BlYmVybWludGEvbGliL2NvcmUubWpzPzY1NjIiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgY2xhbXAsIGVzY2FwZVdoaXRlc3BhY2UgfSBmcm9tICcuL3V0aWwubWpzJztcblxuZnVuY3Rpb24gZW1pdCh2YWx1ZSkge1xuICAgIHJldHVybiAoZGF0YSwgaSkgPT4gKHtcbiAgICAgICAgbWF0Y2hlZDogdHJ1ZSxcbiAgICAgICAgcG9zaXRpb246IGksXG4gICAgICAgIHZhbHVlOiB2YWx1ZVxuICAgIH0pO1xufVxuZnVuY3Rpb24gbWFrZShcbmYpIHtcbiAgICByZXR1cm4gKGRhdGEsIGkpID0+ICh7XG4gICAgICAgIG1hdGNoZWQ6IHRydWUsXG4gICAgICAgIHBvc2l0aW9uOiBpLFxuICAgICAgICB2YWx1ZTogZihkYXRhLCBpKVxuICAgIH0pO1xufVxuZnVuY3Rpb24gYWN0aW9uKFxuZikge1xuICAgIHJldHVybiAoZGF0YSwgaSkgPT4ge1xuICAgICAgICBmKGRhdGEsIGkpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbWF0Y2hlZDogdHJ1ZSxcbiAgICAgICAgICAgIHBvc2l0aW9uOiBpLFxuICAgICAgICAgICAgdmFsdWU6IG51bGxcbiAgICAgICAgfTtcbiAgICB9O1xufVxuZnVuY3Rpb24gZmFpbChcbmRhdGEsIGkpIHtcbiAgICByZXR1cm4geyBtYXRjaGVkOiBmYWxzZSB9O1xufVxuZnVuY3Rpb24gZXJyb3IobWVzc2FnZSkge1xuICAgIHJldHVybiAoZGF0YSwgaSkgPT4ge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoKG1lc3NhZ2UgaW5zdGFuY2VvZiBGdW5jdGlvbikgPyBtZXNzYWdlKGRhdGEsIGkpIDogbWVzc2FnZSk7XG4gICAgfTtcbn1cbmZ1bmN0aW9uIHRva2VuKFxub25Ub2tlbixcbm9uRW5kKSB7XG4gICAgcmV0dXJuIChkYXRhLCBpKSA9PiB7XG4gICAgICAgIGxldCBwb3NpdGlvbiA9IGk7XG4gICAgICAgIGxldCB2YWx1ZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgaWYgKGkgPCBkYXRhLnRva2Vucy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHZhbHVlID0gb25Ub2tlbihkYXRhLnRva2Vuc1tpXSwgZGF0YSwgaSk7XG4gICAgICAgICAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHBvc2l0aW9uKys7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBvbkVuZD8uKGRhdGEsIGkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAodmFsdWUgPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgID8geyBtYXRjaGVkOiBmYWxzZSB9XG4gICAgICAgICAgICA6IHtcbiAgICAgICAgICAgICAgICBtYXRjaGVkOiB0cnVlLFxuICAgICAgICAgICAgICAgIHBvc2l0aW9uOiBwb3NpdGlvbixcbiAgICAgICAgICAgICAgICB2YWx1ZTogdmFsdWVcbiAgICAgICAgICAgIH07XG4gICAgfTtcbn1cbmZ1bmN0aW9uIGFueShkYXRhLCBpKSB7XG4gICAgcmV0dXJuIChpIDwgZGF0YS50b2tlbnMubGVuZ3RoKVxuICAgICAgICA/IHtcbiAgICAgICAgICAgIG1hdGNoZWQ6IHRydWUsXG4gICAgICAgICAgICBwb3NpdGlvbjogaSArIDEsXG4gICAgICAgICAgICB2YWx1ZTogZGF0YS50b2tlbnNbaV1cbiAgICAgICAgfVxuICAgICAgICA6IHsgbWF0Y2hlZDogZmFsc2UgfTtcbn1cbmZ1bmN0aW9uIHNhdGlzZnkoXG50ZXN0KSB7XG4gICAgcmV0dXJuIChkYXRhLCBpKSA9PiAoaSA8IGRhdGEudG9rZW5zLmxlbmd0aCAmJiB0ZXN0KGRhdGEudG9rZW5zW2ldLCBkYXRhLCBpKSlcbiAgICAgICAgPyB7XG4gICAgICAgICAgICBtYXRjaGVkOiB0cnVlLFxuICAgICAgICAgICAgcG9zaXRpb246IGkgKyAxLFxuICAgICAgICAgICAgdmFsdWU6IGRhdGEudG9rZW5zW2ldXG4gICAgICAgIH1cbiAgICAgICAgOiB7IG1hdGNoZWQ6IGZhbHNlIH07XG59XG5mdW5jdGlvbiBtYXBJbm5lcihyLCBmKSB7XG4gICAgcmV0dXJuIChyLm1hdGNoZWQpID8gKHtcbiAgICAgICAgbWF0Y2hlZDogdHJ1ZSxcbiAgICAgICAgcG9zaXRpb246IHIucG9zaXRpb24sXG4gICAgICAgIHZhbHVlOiBmKHIudmFsdWUsIHIucG9zaXRpb24pXG4gICAgfSkgOiByO1xufVxuZnVuY3Rpb24gbWFwT3V0ZXIociwgZikge1xuICAgIHJldHVybiAoci5tYXRjaGVkKSA/IGYocikgOiByO1xufVxuZnVuY3Rpb24gbWFwKHAsIG1hcHBlcikge1xuICAgIHJldHVybiAoZGF0YSwgaSkgPT4gbWFwSW5uZXIocChkYXRhLCBpKSwgKHYsIGopID0+IG1hcHBlcih2LCBkYXRhLCBpLCBqKSk7XG59XG5mdW5jdGlvbiBtYXAxKHAsXG5tYXBwZXIpIHtcbiAgICByZXR1cm4gKGRhdGEsIGkpID0+IG1hcE91dGVyKHAoZGF0YSwgaSksIChtKSA9PiBtYXBwZXIobSwgZGF0YSwgaSkpO1xufVxuZnVuY3Rpb24gcGVlayhwLCBmKSB7XG4gICAgcmV0dXJuIChkYXRhLCBpKSA9PiB7XG4gICAgICAgIGNvbnN0IHIgPSBwKGRhdGEsIGkpO1xuICAgICAgICBmKHIsIGRhdGEsIGkpO1xuICAgICAgICByZXR1cm4gcjtcbiAgICB9O1xufVxuZnVuY3Rpb24gb3B0aW9uKHAsIGRlZikge1xuICAgIHJldHVybiAoZGF0YSwgaSkgPT4ge1xuICAgICAgICBjb25zdCByID0gcChkYXRhLCBpKTtcbiAgICAgICAgcmV0dXJuIChyLm1hdGNoZWQpXG4gICAgICAgICAgICA/IHJcbiAgICAgICAgICAgIDoge1xuICAgICAgICAgICAgICAgIG1hdGNoZWQ6IHRydWUsXG4gICAgICAgICAgICAgICAgcG9zaXRpb246IGksXG4gICAgICAgICAgICAgICAgdmFsdWU6IGRlZlxuICAgICAgICAgICAgfTtcbiAgICB9O1xufVxuZnVuY3Rpb24gbm90KHApIHtcbiAgICByZXR1cm4gKGRhdGEsIGkpID0+IHtcbiAgICAgICAgY29uc3QgciA9IHAoZGF0YSwgaSk7XG4gICAgICAgIHJldHVybiAoci5tYXRjaGVkKVxuICAgICAgICAgICAgPyB7IG1hdGNoZWQ6IGZhbHNlIH1cbiAgICAgICAgICAgIDoge1xuICAgICAgICAgICAgICAgIG1hdGNoZWQ6IHRydWUsXG4gICAgICAgICAgICAgICAgcG9zaXRpb246IGksXG4gICAgICAgICAgICAgICAgdmFsdWU6IHRydWVcbiAgICAgICAgICAgIH07XG4gICAgfTtcbn1cbmZ1bmN0aW9uIGNob2ljZSguLi5wcykge1xuICAgIHJldHVybiAoZGF0YSwgaSkgPT4ge1xuICAgICAgICBmb3IgKGNvbnN0IHAgb2YgcHMpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IHAoZGF0YSwgaSk7XG4gICAgICAgICAgICBpZiAocmVzdWx0Lm1hdGNoZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IG1hdGNoZWQ6IGZhbHNlIH07XG4gICAgfTtcbn1cbmZ1bmN0aW9uIG90aGVyd2lzZShwYSwgcGIpIHtcbiAgICByZXR1cm4gKGRhdGEsIGkpID0+IHtcbiAgICAgICAgY29uc3QgcjEgPSBwYShkYXRhLCBpKTtcbiAgICAgICAgcmV0dXJuIChyMS5tYXRjaGVkKVxuICAgICAgICAgICAgPyByMVxuICAgICAgICAgICAgOiBwYihkYXRhLCBpKTtcbiAgICB9O1xufVxuZnVuY3Rpb24gbG9uZ2VzdCguLi5wcykge1xuICAgIHJldHVybiAoZGF0YSwgaSkgPT4ge1xuICAgICAgICBsZXQgbWF0Y2ggPSB1bmRlZmluZWQ7XG4gICAgICAgIGZvciAoY29uc3QgcCBvZiBwcykge1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gcChkYXRhLCBpKTtcbiAgICAgICAgICAgIGlmIChyZXN1bHQubWF0Y2hlZCAmJiAoIW1hdGNoIHx8IG1hdGNoLnBvc2l0aW9uIDwgcmVzdWx0LnBvc2l0aW9uKSkge1xuICAgICAgICAgICAgICAgIG1hdGNoID0gcmVzdWx0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtYXRjaCB8fCB7IG1hdGNoZWQ6IGZhbHNlIH07XG4gICAgfTtcbn1cbmZ1bmN0aW9uIHRha2VXaGlsZShwLFxudGVzdCkge1xuICAgIHJldHVybiAoZGF0YSwgaSkgPT4ge1xuICAgICAgICBjb25zdCB2YWx1ZXMgPSBbXTtcbiAgICAgICAgbGV0IHN1Y2Nlc3MgPSB0cnVlO1xuICAgICAgICBkbyB7XG4gICAgICAgICAgICBjb25zdCByID0gcChkYXRhLCBpKTtcbiAgICAgICAgICAgIGlmIChyLm1hdGNoZWQgJiYgdGVzdChyLnZhbHVlLCB2YWx1ZXMubGVuZ3RoICsgMSwgZGF0YSwgaSwgci5wb3NpdGlvbikpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZXMucHVzaChyLnZhbHVlKTtcbiAgICAgICAgICAgICAgICBpID0gci5wb3NpdGlvbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHN1Y2Nlc3MgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSB3aGlsZSAoc3VjY2Vzcyk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBtYXRjaGVkOiB0cnVlLFxuICAgICAgICAgICAgcG9zaXRpb246IGksXG4gICAgICAgICAgICB2YWx1ZTogdmFsdWVzXG4gICAgICAgIH07XG4gICAgfTtcbn1cbmZ1bmN0aW9uIHRha2VVbnRpbChwLFxudGVzdCkge1xuICAgIHJldHVybiB0YWtlV2hpbGUocCwgKHZhbHVlLCBuLCBkYXRhLCBpLCBqKSA9PiAhdGVzdCh2YWx1ZSwgbiwgZGF0YSwgaSwgaikpO1xufVxuZnVuY3Rpb24gdGFrZVdoaWxlUChwVmFsdWUsIHBUZXN0KSB7XG4gICAgcmV0dXJuIHRha2VXaGlsZShwVmFsdWUsICh2YWx1ZSwgbiwgZGF0YSwgaSkgPT4gcFRlc3QoZGF0YSwgaSkubWF0Y2hlZCk7XG59XG5mdW5jdGlvbiB0YWtlVW50aWxQKHBWYWx1ZSwgcFRlc3QpIHtcbiAgICByZXR1cm4gdGFrZVdoaWxlKHBWYWx1ZSwgKHZhbHVlLCBuLCBkYXRhLCBpKSA9PiAhcFRlc3QoZGF0YSwgaSkubWF0Y2hlZCk7XG59XG5mdW5jdGlvbiBtYW55KHApIHtcbiAgICByZXR1cm4gdGFrZVdoaWxlKHAsICgpID0+IHRydWUpO1xufVxuZnVuY3Rpb24gbWFueTEocCkge1xuICAgIHJldHVybiBhYihwLCBtYW55KHApLCAoaGVhZCwgdGFpbCkgPT4gW2hlYWQsIC4uLnRhaWxdKTtcbn1cbmZ1bmN0aW9uIGFiKHBhLCBwYixcbmpvaW4pIHtcbiAgICByZXR1cm4gKGRhdGEsIGkpID0+IG1hcE91dGVyKHBhKGRhdGEsIGkpLCAobWEpID0+IG1hcElubmVyKHBiKGRhdGEsIG1hLnBvc2l0aW9uKSwgKHZiLCBqKSA9PiBqb2luKG1hLnZhbHVlLCB2YiwgZGF0YSwgaSwgaikpKTtcbn1cbmZ1bmN0aW9uIGxlZnQocGEsIHBiKSB7XG4gICAgcmV0dXJuIGFiKHBhLCBwYiwgKHZhKSA9PiB2YSk7XG59XG5mdW5jdGlvbiByaWdodChwYSwgcGIpIHtcbiAgICByZXR1cm4gYWIocGEsIHBiLCAodmEsIHZiKSA9PiB2Yik7XG59XG5mdW5jdGlvbiBhYmMocGEsIHBiLCBwYyxcbmpvaW4pIHtcbiAgICByZXR1cm4gKGRhdGEsIGkpID0+IG1hcE91dGVyKHBhKGRhdGEsIGkpLCAobWEpID0+IG1hcE91dGVyKHBiKGRhdGEsIG1hLnBvc2l0aW9uKSwgKG1iKSA9PiBtYXBJbm5lcihwYyhkYXRhLCBtYi5wb3NpdGlvbiksICh2YywgaikgPT4gam9pbihtYS52YWx1ZSwgbWIudmFsdWUsIHZjLCBkYXRhLCBpLCBqKSkpKTtcbn1cbmZ1bmN0aW9uIG1pZGRsZShwYSwgcGIsIHBjKSB7XG4gICAgcmV0dXJuIGFiYyhwYSwgcGIsIHBjLCAocmEsIHJiKSA9PiByYik7XG59XG5mdW5jdGlvbiBhbGwoLi4ucHMpIHtcbiAgICByZXR1cm4gKGRhdGEsIGkpID0+IHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgICAgIGxldCBwb3NpdGlvbiA9IGk7XG4gICAgICAgIGZvciAoY29uc3QgcCBvZiBwcykge1xuICAgICAgICAgICAgY29uc3QgcjEgPSBwKGRhdGEsIHBvc2l0aW9uKTtcbiAgICAgICAgICAgIGlmIChyMS5tYXRjaGVkKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2gocjEudmFsdWUpO1xuICAgICAgICAgICAgICAgIHBvc2l0aW9uID0gcjEucG9zaXRpb247XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4geyBtYXRjaGVkOiBmYWxzZSB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBtYXRjaGVkOiB0cnVlLFxuICAgICAgICAgICAgcG9zaXRpb246IHBvc2l0aW9uLFxuICAgICAgICAgICAgdmFsdWU6IHJlc3VsdFxuICAgICAgICB9O1xuICAgIH07XG59XG5mdW5jdGlvbiBza2lwKC4uLnBzKSB7XG4gICAgcmV0dXJuIG1hcChhbGwoLi4ucHMpLCAoKSA9PiBudWxsKTtcbn1cbmZ1bmN0aW9uIGZsYXR0ZW4oLi4ucHMpIHtcbiAgICByZXR1cm4gZmxhdHRlbjEoYWxsKC4uLnBzKSk7XG59XG5mdW5jdGlvbiBmbGF0dGVuMShwKSB7XG4gICAgcmV0dXJuIG1hcChwLCAodnMpID0+IHZzLmZsYXRNYXAoKHYpID0+IHYpKTtcbn1cbmZ1bmN0aW9uIHNlcEJ5MShwVmFsdWUsIHBTZXApIHtcbiAgICByZXR1cm4gYWIocFZhbHVlLCBtYW55KHJpZ2h0KHBTZXAsIHBWYWx1ZSkpLCAoaGVhZCwgdGFpbCkgPT4gW2hlYWQsIC4uLnRhaWxdKTtcbn1cbmZ1bmN0aW9uIHNlcEJ5KHBWYWx1ZSwgcFNlcCkge1xuICAgIHJldHVybiBvdGhlcndpc2Uoc2VwQnkxKHBWYWx1ZSwgcFNlcCksIGVtaXQoW10pKTtcbn1cbmZ1bmN0aW9uIGNoYWluUmVkdWNlKGFjYyxcbmYpIHtcbiAgICByZXR1cm4gKGRhdGEsIGkpID0+IHtcbiAgICAgICAgbGV0IGxvb3AgPSB0cnVlO1xuICAgICAgICBsZXQgYWNjMSA9IGFjYztcbiAgICAgICAgbGV0IHBvcyA9IGk7XG4gICAgICAgIGRvIHtcbiAgICAgICAgICAgIGNvbnN0IHIgPSBmKGFjYzEsIGRhdGEsIHBvcykoZGF0YSwgcG9zKTtcbiAgICAgICAgICAgIGlmIChyLm1hdGNoZWQpIHtcbiAgICAgICAgICAgICAgICBhY2MxID0gci52YWx1ZTtcbiAgICAgICAgICAgICAgICBwb3MgPSByLnBvc2l0aW9uO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbG9vcCA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IHdoaWxlIChsb29wKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG1hdGNoZWQ6IHRydWUsXG4gICAgICAgICAgICBwb3NpdGlvbjogcG9zLFxuICAgICAgICAgICAgdmFsdWU6IGFjYzFcbiAgICAgICAgfTtcbiAgICB9O1xufVxuZnVuY3Rpb24gcmVkdWNlTGVmdChhY2MsIHAsXG5yZWR1Y2VyKSB7XG4gICAgcmV0dXJuIGNoYWluUmVkdWNlKGFjYywgKGFjYykgPT4gbWFwKHAsICh2LCBkYXRhLCBpLCBqKSA9PiByZWR1Y2VyKGFjYywgdiwgZGF0YSwgaSwgaikpKTtcbn1cbmZ1bmN0aW9uIHJlZHVjZVJpZ2h0KHAsIGFjYyxcbnJlZHVjZXIpIHtcbiAgICByZXR1cm4gbWFwKG1hbnkocCksICh2cywgZGF0YSwgaSwgaikgPT4gdnMucmVkdWNlUmlnaHQoKGFjYywgdikgPT4gcmVkdWNlcih2LCBhY2MsIGRhdGEsIGksIGopLCBhY2MpKTtcbn1cbmZ1bmN0aW9uIGxlZnRBc3NvYzEocExlZnQsIHBPcGVyKSB7XG4gICAgcmV0dXJuIGNoYWluKHBMZWZ0LCAodjApID0+IHJlZHVjZUxlZnQodjAsIHBPcGVyLCAoYWNjLCBmKSA9PiBmKGFjYykpKTtcbn1cbmZ1bmN0aW9uIHJpZ2h0QXNzb2MxKHBPcGVyLCBwUmlnaHQpIHtcbiAgICByZXR1cm4gYWIocmVkdWNlUmlnaHQocE9wZXIsICh5KSA9PiB5LCAoZiwgYWNjKSA9PiAoeSkgPT4gZihhY2MoeSkpKSwgcFJpZ2h0LCAoZiwgdikgPT4gZih2KSk7XG59XG5mdW5jdGlvbiBsZWZ0QXNzb2MyKHBMZWZ0LCBwT3BlciwgcFJpZ2h0KSB7XG4gICAgcmV0dXJuIGNoYWluKHBMZWZ0LCAodjApID0+IHJlZHVjZUxlZnQodjAsIGFiKHBPcGVyLCBwUmlnaHQsIChmLCB5KSA9PiBbZiwgeV0pLCAoYWNjLCBbZiwgeV0pID0+IGYoYWNjLCB5KSkpO1xufVxuZnVuY3Rpb24gcmlnaHRBc3NvYzIocExlZnQsIHBPcGVyLCBwUmlnaHQpIHtcbiAgICByZXR1cm4gYWIocmVkdWNlUmlnaHQoYWIocExlZnQsIHBPcGVyLCAoeCwgZikgPT4gW3gsIGZdKSwgKHkpID0+IHksIChbeCwgZl0sIGFjYykgPT4gKHkpID0+IGYoeCwgYWNjKHkpKSksIHBSaWdodCwgKGYsIHYpID0+IGYodikpO1xufVxuZnVuY3Rpb24gY29uZGl0aW9uKFxuY29uZCwgcFRydWUsIHBGYWxzZSkge1xuICAgIHJldHVybiAoZGF0YSwgaSkgPT4gKGNvbmQoZGF0YSwgaSkpXG4gICAgICAgID8gcFRydWUoZGF0YSwgaSlcbiAgICAgICAgOiBwRmFsc2UoZGF0YSwgaSk7XG59XG5mdW5jdGlvbiBkZWNpZGUocCkge1xuICAgIHJldHVybiAoZGF0YSwgaSkgPT4gbWFwT3V0ZXIocChkYXRhLCBpKSwgKG0xKSA9PiBtMS52YWx1ZShkYXRhLCBtMS5wb3NpdGlvbikpO1xufVxuZnVuY3Rpb24gY2hhaW4ocCxcbmYpIHtcbiAgICByZXR1cm4gKGRhdGEsIGkpID0+IG1hcE91dGVyKHAoZGF0YSwgaSksIChtMSkgPT4gZihtMS52YWx1ZSwgZGF0YSwgaSwgbTEucG9zaXRpb24pKGRhdGEsIG0xLnBvc2l0aW9uKSk7XG59XG5mdW5jdGlvbiBhaGVhZChwKSB7XG4gICAgcmV0dXJuIChkYXRhLCBpKSA9PiBtYXBPdXRlcihwKGRhdGEsIGkpLCAobTEpID0+ICh7XG4gICAgICAgIG1hdGNoZWQ6IHRydWUsXG4gICAgICAgIHBvc2l0aW9uOiBpLFxuICAgICAgICB2YWx1ZTogbTEudmFsdWVcbiAgICB9KSk7XG59XG5mdW5jdGlvbiByZWN1cnNpdmUoZikge1xuICAgIHJldHVybiBmdW5jdGlvbiAoZGF0YSwgaSkge1xuICAgICAgICByZXR1cm4gZigpKGRhdGEsIGkpO1xuICAgIH07XG59XG5mdW5jdGlvbiBzdGFydChkYXRhLCBpKSB7XG4gICAgcmV0dXJuIChpICE9PSAwKVxuICAgICAgICA/IHsgbWF0Y2hlZDogZmFsc2UgfVxuICAgICAgICA6IHtcbiAgICAgICAgICAgIG1hdGNoZWQ6IHRydWUsXG4gICAgICAgICAgICBwb3NpdGlvbjogaSxcbiAgICAgICAgICAgIHZhbHVlOiB0cnVlXG4gICAgICAgIH07XG59XG5mdW5jdGlvbiBlbmQoZGF0YSwgaSkge1xuICAgIHJldHVybiAoaSA8IGRhdGEudG9rZW5zLmxlbmd0aClcbiAgICAgICAgPyB7IG1hdGNoZWQ6IGZhbHNlIH1cbiAgICAgICAgOiB7XG4gICAgICAgICAgICBtYXRjaGVkOiB0cnVlLFxuICAgICAgICAgICAgcG9zaXRpb246IGksXG4gICAgICAgICAgICB2YWx1ZTogdHJ1ZVxuICAgICAgICB9O1xufVxuZnVuY3Rpb24gcmVtYWluaW5nVG9rZW5zTnVtYmVyKGRhdGEsIGkpIHtcbiAgICByZXR1cm4gZGF0YS50b2tlbnMubGVuZ3RoIC0gaTtcbn1cbmZ1bmN0aW9uIHBhcnNlclBvc2l0aW9uKGRhdGEsIGksIGZvcm1hdFRva2VuLCBjb250ZXh0VG9rZW5zID0gMykge1xuICAgIGNvbnN0IGxlbiA9IGRhdGEudG9rZW5zLmxlbmd0aDtcbiAgICBjb25zdCBsb3dJbmRleCA9IGNsYW1wKDAsIGkgLSBjb250ZXh0VG9rZW5zLCBsZW4gLSBjb250ZXh0VG9rZW5zKTtcbiAgICBjb25zdCBoaWdoSW5kZXggPSBjbGFtcChjb250ZXh0VG9rZW5zLCBpICsgMSArIGNvbnRleHRUb2tlbnMsIGxlbik7XG4gICAgY29uc3QgdG9rZW5zU2xpY2UgPSBkYXRhLnRva2Vucy5zbGljZShsb3dJbmRleCwgaGlnaEluZGV4KTtcbiAgICBjb25zdCBsaW5lcyA9IFtdO1xuICAgIGNvbnN0IGluZGV4V2lkdGggPSBTdHJpbmcoaGlnaEluZGV4IC0gMSkubGVuZ3RoICsgMTtcbiAgICBpZiAoaSA8IDApIHtcbiAgICAgICAgbGluZXMucHVzaChgJHtTdHJpbmcoaSkucGFkU3RhcnQoaW5kZXhXaWR0aCl9ID4+YCk7XG4gICAgfVxuICAgIGlmICgwIDwgbG93SW5kZXgpIHtcbiAgICAgICAgbGluZXMucHVzaCgnLi4uJy5wYWRTdGFydChpbmRleFdpZHRoICsgNikpO1xuICAgIH1cbiAgICBmb3IgKGxldCBqID0gMDsgaiA8IHRva2Vuc1NsaWNlLmxlbmd0aDsgaisrKSB7XG4gICAgICAgIGNvbnN0IGluZGV4ID0gbG93SW5kZXggKyBqO1xuICAgICAgICBsaW5lcy5wdXNoKGAke1N0cmluZyhpbmRleCkucGFkU3RhcnQoaW5kZXhXaWR0aCl9ICR7KGluZGV4ID09PSBpID8gJz4nIDogJyAnKX0gJHtlc2NhcGVXaGl0ZXNwYWNlKGZvcm1hdFRva2VuKHRva2Vuc1NsaWNlW2pdKSl9YCk7XG4gICAgfVxuICAgIGlmIChoaWdoSW5kZXggPCBsZW4pIHtcbiAgICAgICAgbGluZXMucHVzaCgnLi4uJy5wYWRTdGFydChpbmRleFdpZHRoICsgNikpO1xuICAgIH1cbiAgICBpZiAobGVuIDw9IGkpIHtcbiAgICAgICAgbGluZXMucHVzaChgJHtTdHJpbmcoaSkucGFkU3RhcnQoaW5kZXhXaWR0aCl9ID4+YCk7XG4gICAgfVxuICAgIHJldHVybiBsaW5lcy5qb2luKCdcXG4nKTtcbn1cbmZ1bmN0aW9uIHBhcnNlKHBhcnNlciwgdG9rZW5zLCBvcHRpb25zLCBmb3JtYXRUb2tlbiA9IEpTT04uc3RyaW5naWZ5KSB7XG4gICAgY29uc3QgZGF0YSA9IHsgdG9rZW5zOiB0b2tlbnMsIG9wdGlvbnM6IG9wdGlvbnMgfTtcbiAgICBjb25zdCByZXN1bHQgPSBwYXJzZXIoZGF0YSwgMCk7XG4gICAgaWYgKCFyZXN1bHQubWF0Y2hlZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIG1hdGNoJyk7XG4gICAgfVxuICAgIGlmIChyZXN1bHQucG9zaXRpb24gPCBkYXRhLnRva2Vucy5sZW5ndGgpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBQYXJ0aWFsIG1hdGNoLiBQYXJzaW5nIHN0b3BwZWQgYXQ6XFxuJHtwYXJzZXJQb3NpdGlvbihkYXRhLCByZXN1bHQucG9zaXRpb24sIGZvcm1hdFRva2VuKX1gKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdC52YWx1ZTtcbn1cbmZ1bmN0aW9uIHRyeVBhcnNlKHBhcnNlciwgdG9rZW5zLCBvcHRpb25zKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gcGFyc2VyKHsgdG9rZW5zOiB0b2tlbnMsIG9wdGlvbnM6IG9wdGlvbnMgfSwgMCk7XG4gICAgcmV0dXJuIChyZXN1bHQubWF0Y2hlZClcbiAgICAgICAgPyByZXN1bHQudmFsdWVcbiAgICAgICAgOiB1bmRlZmluZWQ7XG59XG5mdW5jdGlvbiBtYXRjaChtYXRjaGVyLCB0b2tlbnMsIG9wdGlvbnMpIHtcbiAgICBjb25zdCByZXN1bHQgPSBtYXRjaGVyKHsgdG9rZW5zOiB0b2tlbnMsIG9wdGlvbnM6IG9wdGlvbnMgfSwgMCk7XG4gICAgcmV0dXJuIHJlc3VsdC52YWx1ZTtcbn1cblxuZXhwb3J0IHsgYWIsIGFiYywgYWN0aW9uLCBhaGVhZCwgYWxsLCBhbGwgYXMgYW5kLCBhbnksIGNoYWluLCBjaGFpblJlZHVjZSwgY2hvaWNlLCBjb25kaXRpb24sIGRlY2lkZSwgc2tpcCBhcyBkaXNjYXJkLCBvdGhlcndpc2UgYXMgZWl0aGVyT3IsIGVtaXQsIGVuZCwgZW5kIGFzIGVvZiwgZXJyb3IsIGZhaWwsIGZsYXR0ZW4sIGZsYXR0ZW4xLCBsZWZ0LCBsZWZ0QXNzb2MxLCBsZWZ0QXNzb2MyLCBsb25nZXN0LCBhaGVhZCBhcyBsb29rQWhlYWQsIG1ha2UsIG1hbnksIG1hbnkxLCBtYXAsIG1hcDEsIG1hdGNoLCBtaWRkbGUsIG5vdCwgZW1pdCBhcyBvZiwgb3B0aW9uLCBjaG9pY2UgYXMgb3IsIG90aGVyd2lzZSwgcGFyc2UsIHBhcnNlclBvc2l0aW9uLCBwZWVrLCByZWN1cnNpdmUsIHJlZHVjZUxlZnQsIHJlZHVjZVJpZ2h0LCByZW1haW5pbmdUb2tlbnNOdW1iZXIsIHJpZ2h0LCByaWdodEFzc29jMSwgcmlnaHRBc3NvYzIsIHNhdGlzZnksIHNlcEJ5LCBzZXBCeTEsIHNraXAsIG1hbnkxIGFzIHNvbWUsIHN0YXJ0LCB0YWtlVW50aWwsIHRha2VVbnRpbFAsIHRha2VXaGlsZSwgdGFrZVdoaWxlUCwgdG9rZW4sIHRyeVBhcnNlIH07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/peberminta/lib/core.mjs\n");

/***/ }),

/***/ "(action-browser)/./node_modules/peberminta/lib/util.mjs":
/*!**********************************************!*\
  !*** ./node_modules/peberminta/lib/util.mjs ***!
  \**********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   clamp: () => (/* binding */ clamp),\n/* harmony export */   escapeWhitespace: () => (/* binding */ escapeWhitespace)\n/* harmony export */ });\nfunction clamp(left, x, right) {\n    return Math.max(left, Math.min(x, right));\n}\nfunction escapeWhitespace(str) {\n    return str.replace(/(\\t)|(\\r)|(\\n)/g, (m, t, r) => t ? '\\\\t' : r ? '\\\\r' : '\\\\n');\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9wZWJlcm1pbnRhL2xpYi91dGlsLm1qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFbUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9teS1wcm9qZWN0Ly4vbm9kZV9tb2R1bGVzL3BlYmVybWludGEvbGliL3V0aWwubWpzPzNhYzciXSwic291cmNlc0NvbnRlbnQiOlsiZnVuY3Rpb24gY2xhbXAobGVmdCwgeCwgcmlnaHQpIHtcbiAgICByZXR1cm4gTWF0aC5tYXgobGVmdCwgTWF0aC5taW4oeCwgcmlnaHQpKTtcbn1cbmZ1bmN0aW9uIGVzY2FwZVdoaXRlc3BhY2Uoc3RyKSB7XG4gICAgcmV0dXJuIHN0ci5yZXBsYWNlKC8oXFx0KXwoXFxyKXwoXFxuKS9nLCAobSwgdCwgcikgPT4gdCA/ICdcXFxcdCcgOiByID8gJ1xcXFxyJyA6ICdcXFxcbicpO1xufVxuXG5leHBvcnQgeyBjbGFtcCwgZXNjYXBlV2hpdGVzcGFjZSB9O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/peberminta/lib/util.mjs\n");

/***/ })

};
;